"""Location tool

Syntax: `gridlabd location [OPTIONS ...] [FILENAME=KEY[:VALUE][,...] ...]`

Options:

* `--debug`: enable debug traceback on exception

* `--find[=KEY[:VALUE][,...]]`: get location settings

* `--format=FORMAT[,OPTION[:VALUE[,...]]]

* `--quiet`: suppress error messages

* `--silent`: suppress all error messages

* `--system[=KEY[:VALUE][,...]]`: get/set the default location

* `--verbose`: enable verbose output, if any

* `--warning`: suppress warning messages

Description:

The `location` tool allows configuration of the location of a model.

The `location` tool `--system` option is used to setup the system's default
location for models when not location data is not specified in the model.
When values are change, the location data is returned and the new location
is stored in `GLD_ETC/location_config.glm

The `location` tool `--find` options can identify the current location of a
system or a location based on partial information.

Location setting on `FILENAME` will be performed in place, i.e., the file will
first be read and the it will be written with the new values. The result
output to stdout will be the previous values.

The keys and globals handled by the `location` tools include the following:

* `latitude`: the location's latitude

* `longitude`: the location's longitude

* `zipcode`: the location's postal code

* `city`: the location's city

* `county`: the location's county

* `state`: the location's state

* `region`: the location's region

* `country`: the location's country

Caveat:

Although the `--find` option allows multiple addresses to be resolved, it is
certainly not efficient to do more than a few queries this way. If you need
to resolve large number of addresses then you should use the batch feature of
the `geocoder` module.

Examples:

Get the current location

    gridlabd location --find

Display the default location

    gridlabd location --system

Set the location in a model file

    gridlabd location ieee123.json=country:US,state:CA,county:Kern,city:Bakersfield

"""

import os
import sys
import json
import datetime as dt
import framework as app
import geocoder
import edit

LOCATIONKEYS = ["latitude","longitude","city","zipcode","county","state","region","country"]
PROVIDER = "arcgis"
PROVIDERCONFIG = {
    "arcgis" : {
        "lat" : "latitude",
        "lng" : "longitude",
        "city" : "city",
        "postal" : "zipcode",
        "raw.address.RegionAbbr" : "state",
        "raw.address.Subregion" : "county",
        "country" : "country",
    }
}

class LocationError(Exception):
    """Location exception"""

class Location:

    def __init__(self,**kwargs):

        for key,value in kwargs.items():
            if not key in LOCATIONKEYS:
                raise LocationError(f"'{key}' is not a valid location key")
            setattr(self,key,value)
        for key in LOCATIONKEYS:
            if not hasattr(self,key):
                setattr(self,key,"")

    def __repr__(self):
        return str(dict(self.items()))

    def __getitem__(self,key):

        return getattr(self,key)

    def keys(self):
        return LOCATIONKEYS

    def values(self):
        return [getattr(self,x) for x in LOCATIONKEYS]

    def items(self):
        return [(x,getattr(self,x)) for x in LOCATIONKEYS]

def system(**kwargs:dict) -> dict:
    """Get/set system location settings

    Arguments:

    * `latitude`: new latitude

    * `longitude`: new longitude

    * `number`: new street number

    * `street`: new street name

    * `zipcode`: new zipcode

    * `city`: new city

    * `county`: new county

    * `state`: new state

    * `region`: new region

    * `country`: new country

    Returns:

    * previous location settings
    """
    glm = os.path.join(os.environ["GLD_ETC"],"location.glm")
    data = json.loads(app.gridlabd(glm,"--globals=json").stdout.decode('utf-8'))
    result = {}
    for item in LOCATIONKEYS:
        result[item] = data[item]['value'] if item in data else ""

    save = dict(result)
    for x,y in kwargs.items():
        if not x in save:
            raise LocationError(f"'{x}' is not a valid location key")
        save[x] = y

    if save != result:
        with open(glm,"w") as fh:
            print(f"// generated by {' '.join(sys.argv)} on {dt.datetime.now()}",file=fh)
            for x,y in save.items():
                setter = "set" if x in data else "define"
                print(f'#{setter} {x}="{y}"',file=fh)
    return Location(**result)

def find(*address:list[str]) -> dict:
    """Find location data

    Arguments:

    * `kwargs`: Partial location data (see `system()`). None return IP location.

    Returns:

    * Location data
    """
    if len(address) == 0 or not address[0]:

        data = geocoder.ip('me')
        result = {}
        for item in LOCATIONKEYS:
            result[item] = getattr(data,item) if hasattr(data,item) else ""
        if not result:
            raise LocationError("unable to find current location")
        address = (f"{result['city']}, {result['state']}, {result['country']}",)

    result = []
    for item in address:
        location = getattr(geocoder,PROVIDER)(address)
        data = getattr(geocoder,PROVIDER)(location.latlng,method='reverse')
        if data.ok:
            found = {}
            for key,value in PROVIDERCONFIG[PROVIDER].items():
                for subkey in key.split("."):
                    found[value] = (found[value] if value in found else data.json)[subkey]
            for key,value in found.items():
                found[key] = str(value)
            result.append(found)
        else:
            raise LocationError("no location found")

    return [Location(**x) for x in result]

def set_location(file:str,**kwargs) -> dict:
    """Set location in file

    Arguments:

    * `file`: file in which to set location data

    * `**kwargs`: location data

    Returns:

    * Previous values
    """
    data = json.load(open(file,"r"))
    result = {x:(data["globals"][x]["value"] if x in data["globals"] else "") for x in LOCATIONKEYS}
    for key,value in kwargs.items():
        if not key in LOCATIONKEYS:
            raise LocationError(f"'{key}' is not a valid location key")
        data["globals"][key] = {
            "type" : "char32",
            "access" : "public",
            "value" : value,
        }
    json.dump(data,open(file,"w"),indent=4)
    return Location(**result)

def get_location(file:str) -> dict:
    """Get location data in file

    Arguments:

    * `file`: file from which to get location data

    Returns:

    * Current values
    """
    data = json.load(open(file,"r"))
    result = {x:(data["globals"][x]["value"] if x in data["globals"] else "") for x in LOCATIONKEYS}
    return Location(**result)

def main(argv:list) -> int:
    """Main location routine

    Arguments:

    * `argv`: command line argument list

    Returns:

    * Exit code
    """
    if len(argv) == 1:

        print("\n".join([x for x in __doc__.split("\n") if x.startswith("Syntax: ")]))
        return app.E_SYNTAX

    args = app.read_stdargs(argv)

    def output_raw(data,**kwargs):
        print(data,**kwargs)

    def output_csv(data,**kwargs):
        if isinstance(data,list):
            print(",".join(LOCATIONKEYS))
            for item in data:
                print(",".join([str(item[x]) for x in LOCATIONKEYS]))
        elif isinstance(data,Location):
            print(",".join(LOCATIONKEYS))
            print(",".join([str(data[x]) for x in LOCATIONKEYS]))
        else:
            raise LocationError(f"unable to output '{type(data)}' as CSV")

    def output_json(data,**kwargs):
        if isinstance(data,list):
            print(json.dumps([dict(x.items()) for x in data],**kwargs))
        elif isinstance(data,Location):
            print(json.dumps(dict(data.items()),**kwargs))
        else:
            raise LocationError(f"unable to output '{type(data)}' as CSV")


    outputter = output_raw
    outputter_options = {}

    result = []
    for key,value in args:

        if key in ["-h","--help","help"]:
            print(__doc__,file=sys.stdout)

        elif key in ["--format"]:

            if len(value) == 0:

                app.error("missing format")
                return app.E_MISSING

            
            elif value[0] == "csv":

                if len(value) > 1:
                    app.error(f"invalid format options '{','.join(value[1:])}'")
                    return app.E_INVALID
                outputter = output_csv

            elif value[0] == "json":

                options = {x:y for x,y in [z.split(":",1) for z in value[1:]]} if len(value) > 1 else {}
                _bool = lambda x: x=="true" if x in ["true","false"] else None,
                for x,y in {
                    "indent": int,
                    "skipkeys": _bool,
                    "ensure_ascii": _bool,
                    "check_circular": _bool,
                    "allow_nan": _bool,
                    "sort_keys": _bool,
                }.items():
                    try:
                        options[x] = y(options[x])
                    except:
                        pass
                outputter = output_json
                outputter_options = options

        elif key in ["--system"]:

            options = dict([x.split(":",1) for x in value])
            result = system(**options)

        elif key in ["--find"]:

            address = [",".join(value)]
            result.extend(find(*address))

        elif os.path.exists(key):

            if not value:
                result = get_location(key)
            else:
                options = dict([x.split(":",1) for x in value])
                result = set_location(key,**options)

        else:
            error(f"'{key}={value}' is invalid")
            return app.E_INVALID

    if result:
        outputter(result,**outputter_options)

    return app.E_OK

if __name__ == "__main__":

    try:

        # TODO: development testing -- only needed when developing/debugging
        # if not sys.argv[0]:
        #     options = []
        #     # options = ["--format=raw"]
        #     # options = ["--format=csv"]
        #     # options = ["--format=json,indent:4"]
        #     # options = ["--debug","--format=raw"]
        #     # options = ["--debug","--format=csv"]
        #     # options = ["--debug","--format=json,indent:4"]

        #     # sys.argv = [__file__,*options,"--system"]
        #     # sys.argv = [__file__,*options,"--system=city:Menlo Park,state:CA,region:west,country:US"]
        #     # sys.argv = [__file__,*options,"--find"]
        #     # sys.argv = [__file__,*options,"--find=2575 Sand Hill Rd, Menlo Park, CA, USA"]
        #     # sys.argv = [__file__,*options,"--find=2575 Sand Hill Rd, Menlo Park, CA","--find=7443 87th Dr NE, Marysville, WA"]
        #     # sys.argv = [__file__,*options,"autotest/test_moutils.json"]
        #     # sys.argv = [__file__,*options,"autotest/test_moutils.json=city:Seattle"]

        rc = main(sys.argv)
        exit(rc)

    except KeyboardInterrupt:

        exit(app.E_INTERRUPT)

    except Exception as exc:

        if app.DEBUG:
            raise exc

        if not app.QUIET:
            e_type,e_value,e_trace = sys.exc_info()
            tb = app.traceback.TracebackException(e_type,e_value,e_trace).stack[1]
            print(f"EXCEPTION [{app.EXEFILE}@{tb.lineno}]: ({e_type.__name__}) {e_value}",file=sys.stderr)

        exit(app.E_EXCEPTION)

